// Run this program through the Oz interpreter by calling
//    runFull "declarative" "Sem1.txt" "Sem1.out"
// Explain the resulting store

local X in       // line 46
  local Y in     // line 48
    X = 1        // line 50
    Y = pair(1:X 2:X)     // line 52
    case Y of pair(1:Z 2:W) then     // line 55
      local S in                   // line 59
        {IntPlus Z W S}          // line 59
       skip Full
      end
      else
        skip Basic
    end
  end
end

// Sem1.out  
// [local ["X"] [local ["Y"] [X = 1,local ["EXU1","EXU2"] [EXU1 = X,EXU2 = X,Y = pair(1:EXU1 2:EXU2)],case Y of pair(1:Z 2:W) then [local ["S"] [local ["EXU1","EXU2","EXU3"] [EXU1 = Z,EXU2 = W,EXU3 = S,"IntPlus" "EXU1" "EXU2" "EXU3"],skip/f]] else [skip]]]]

// the corresponding Explaination is on the line that comment after each instruction

// Store :
// ((15, 12), 2), -------> there are two S, first one, variable "S" been created, ((12),unbound), then IntPlus Z W S, "S"-> ((15,12),2)
// ((14, 13, 11, 10, 8), 1), -------> at first, "X" been created ((8),unbound), and then X=1, "X" ->((8),1), then united X to pair.1 and pair.2, then we have "X" -> ((11,10,8),1), eventually, in IntPlus Z W S, we got "X"->((14,13,11,10,8),1)
// ((9), pair(1:10 2:11)), --------> at first, "Y" been created ((9),unbound), then it bound to pair (1:X 2:X), so we got "Y" -> ((9), pair(1:10 2:11))
// ((1), Primitive Operation), 
// ((2), Primitive Operation),
// ((3), Primitive Operation),
// ((4), Primitive Operation),
// ((5), Primitive Operation),
// ((6), Primitive Operation),
// ((7), Primitive Operation)

// Mutable Store: Empty
// Current Environment : ("S" -> 12, "Z" -> 10, "W" -> 11, "Y" -> 9, "X" -> 8, "IntPlus" -> 1, "IntMinus" -> 2, "Eq" -> 3, "GT" -> 4, "LT" -> 5, "Mod" -> 6, "IntMultiply" -> 7)
// Stack : ""


// The whole program does assign an variable x = 1, and then assign another variable y to a pair, y=(1,1)
// and then sum the first element and the second element of this pair, finally assigns the result to a variable S.
// S will be 2 (first + second = 1 + 1).

// After "local X in ..." executed, we have "X" -> ((8),unbound)

// After "local Y in ..." executed, we have "Y" -> ((9),unbound)

// After "X=1" executed, we have "X" -> ((8),unbound)

// After "Y = pair(1:X 2:X)" executed, we have "Y" -> ((9), pair (1:10,2:11))
// We also have "pair.1" -> ((10),1), "pair.2" -> ((11),1), "X" -> ((11,10,8),1)

// After "case Y of pair(1:Z 2:W) then" executed, we have
// due to Z and W are not local variables, so instead of creating a new store location for them , we only assign the values to them. 
// the Z and W is actually the "pair.1" and "pair.2" in "Y" -> ((9), pair (1:10, 2:11)),so we have "Z" -> ((10),1) "W" -> ((11),1). 

// After "local S in {IntPlus Z W S}" executed, we have
// local S created a variable S first, and assigned it a store location, "S" -> ((12),unbound)
// then "IntPlus Z W S" simply operater two arguments and save the result in S
// "IntPlus Z W S" actually does S= Z IntPlus W, for those Z, W, and S, program created new store location for them.
// so we have "Z" -> ((13),1), "W" -> ((14),1), "S" -> ((15,12),unbound)
// Thus S= Z "+" W = 1 + 1 = 2, "S" -> ((15,12),2)
// and we also have "X" -> ((14,13,11,10,8),1)

